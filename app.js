// Generated by LiveScript 1.5.0
(function(){
  var fs, util, getsecret, koa, koaStatic, koaRouter, koaLogger, glob, on_heroku, selfSignedHttps, debounce, ref$, cfy, yfy, add_noerr, kapp, app, bodyParser, session, passport, SUSamlStrategy, saml, auth, memoizeSingleAsync, sleep, to_dict_list, get_sheet, get_spreadsheet_real, get_spreadsheet, get_seminars_attended_by_user, list_all_users, index_contents, serve_static, i$, len$, port;
  fs = require('fs');
  getsecret = require('getsecret');
  koa = require('koa');
  koaStatic = require('koa-static');
  koaRouter = require('koa-router');
  koaLogger = require('koa-logger');
  glob = require('glob');
  getsecret = require('getsecret');
  on_heroku = process.env.PORT != null;
  if (!on_heroku) {
    selfSignedHttps = require('self-signed-https');
  }
  const { GoogleSpreadsheet } = require('google-spreadsheet');
  const { promisify } = require('util')
  //GoogleSpreadsheet = require('google-spreadsheet');
  debounce = require('promise-debounce');
  ref$ = require('cfy'), cfy = ref$.cfy, yfy = ref$.yfy, add_noerr = ref$.add_noerr;
  kapp = koa();
  kapp.use(koaLogger());
  app = koaRouter();
  bodyParser = require('koa-bodyparser');
  kapp.use(bodyParser({
    extendTypes: {
      json: ['json', '**/json']
    }
  }));
  session = require('koa-generic-session');
  kapp.keys = [getsecret('session_keys')];
  kapp.use(session({
    key: 'test.cookie'
  }));
  passport = require('koa-passport');
  kapp.use(passport.initialize());
  kapp.use(passport.session());

  SUSamlStrategy = require('passport-stanford').Strategy;
  saml = new SUSamlStrategy({
    protocol: 'https://',
    idp: 'prod',
    entityId: 'https://cs547check.herokuapp.com/',
    loginPath: '/login',
    path: '/saml/consume',
    passReqToCallback: true,
    passport: passport,
    decryptionPvk: getsecret('sp_key'),
    decryptionCert: getsecret('sp_cert'),
    host: 'cs547check.herokuapp.com'
  });
  passport.use(saml);
  passport.serializeUser(function(user, done){
    return done(null, user);
  });
  passport.deserializeUser(function(user, done){
    return done(null, user);
  });
  app.post('/saml/consume', passport.authenticate(saml.name, {
    failureRedirect: '/',
    failureFlash: true
  }), function*(){
    return this.redirect('/');
  });
  app.get('/login', passport.authenticate(saml.name, {
    successRedirect: '/',
    failureRedirect: '/login'
  }));

  app.get('/metadata', function*(){
    this.type = 'application/xml';
    this.status = 200;
    return this.body = saml.generateServiceProviderMetadata(getsecret('sp_cert'));
  });
  auth = function*(next){
    if (this.isAuthenticated()) {
      return (yield next);
    } else {
      return this.redirect('/login');
    }
  };
  app.get('/secret', auth, function*(){
    console.log(this.req.user);
    console.log(this.req.user.primary_email);
    return this.body = 'secret stuff';
  });

  memoizeSingleAsync = function(func){
    var debounced_func, cached_val;
    debounced_func = debounce(yfy(func));
    cached_val = null;
    return cfy(function*(){
      var result;
      if (cached_val != null) {
        return cached_val;
      }
      result = (yield debounced_func());
      cached_val = result;
      return result;
    });
  };
  sleep = cfy(function*(time){
    var sleep_base;
    sleep_base = function(msecs, callback){
      return setTimeout(callback, msecs);
    };
    return (yield yfy(sleep_base)(time));
  });
  to_dict_list = function(cells){
    var output, header_cells, body_cells, col_to_name, i$, len$, item, row_idx_to_contents, idx, name, value;
    output = [];
    header_cells = cells.filter(function(x){
      return x.row === 1;
    });
    body_cells = cells.filter(function(x){
      return x.row !== 1;
    });
    col_to_name = {};
    for (i$ = 0, len$ = header_cells.length; i$ < len$; ++i$) {
      item = header_cells[i$];
      col_to_name[item.col] = item.value;
    }
    row_idx_to_contents = [];
    for (i$ = 0, len$ = body_cells.length; i$ < len$; ++i$) {
      item = body_cells[i$];
      idx = item.row - 2;
      name = col_to_name[item.col];
      value = item.value;
      if (row_idx_to_contents[idx] == null) {
        row_idx_to_contents[idx] = {};
      }
      row_idx_to_contents[idx][name] = value;
    }
    return row_idx_to_contents;
  };
  const creds = JSON.parse(getsecret('google_service_account'));
  const doc = new GoogleSpreadsheet(getsecret('spreadsheet_id'));

  async function accessSpreadsheet() {
    console.log("inside accessSpreadsheet");
    await doc.useServiceAccountAuth({
      client_email: creds.client_email,
      private_key: creds.private_key,
    });

    await doc.loadInfo(); // loads document properties and worksheets
    console.log(doc.title);

    const sheet = doc.sheetsByIndex[0]; // or use doc.sheetsById[id]
    console.log(sheet.title);
    console.log(sheet.rowCount);
    return Promise.resolve(sheet);
  }
  async function get_spreadsheet_real() {
    var sheet, cells;
    sheet = await accessSpreadsheet();
    rows = await sheet.getRows();
    return Promise.resolve(rows);
  };
  get_spreadsheet = null;
  (function(){
    var last_time_fetched, cached_spreadsheet_results;
    last_time_fetched = 0;
    cached_spreadsheet_results = null;
    return get_spreadsheet = cfy(function*(){
      var current_time;
      current_time = Date.now();
      if (Math.abs(current_time - last_time_fetched) < 30000) {
        return cached_spreadsheet_results;
      }
      cached_spreadsheet_results = (yield get_spreadsheet_real());
      last_time_fetched = current_time;
      return cached_spreadsheet_results;
    });
  })();
  get_seminars_attended_by_user = cfy(function*(sunetid){
    var spreadsheet, output, output_set, i$, len$, line, cur_sunetid, seminar;
    sunetid = sunetid.trim().toLowerCase();
    spreadsheet = (yield get_spreadsheet());
    output = [];
    output_set = {};
    for (i$ = 0, len$ = spreadsheet.length; i$ < len$; ++i$) {
      line = spreadsheet[i$];
      cur_sunetid = line['SUNet ID'];
      if (cur_sunetid == null) {
        continue;
      }
      if (cur_sunetid.trim().toLowerCase() !== sunetid) {
        continue;
      }
      seminar = line['Which seminar are you currently attending?'];
      if (output_set[seminar] != null) {
        continue;
      }
      // If no longer keeping track of live/non-live attendance, comment out the following block
      attendance_status = line['Attendance:'];
      attendance_string = '';
      if (attendance_status == 'I certify by the Stanford Honor Code that I watched the entire seminar *non-live* (up to 2 per quarter, unless you are an SCPD student or in a timezone that makes live attendance infeasible with email exemption from staff)') {
        attendance_string = '-- Non-Live attendance';
      }
      else {
        attendance_string = '-- Live attendance';
      }
      // End of block.

      output_set[seminar] = true;
      output.push(seminar.concat("  ", attendance_string));
    }
    return output;
  });
  list_all_users = cfy(function*(){
    var spreadsheet, output, output_set, i$, len$, line, sunetid;
    spreadsheet = (yield get_spreadsheet());
    output = [];
    output_set = {};
    for (i$ = 0, len$ = spreadsheet.length; i$ < len$; ++i$) {
      line = spreadsheet[i$];
      sunetid = line['SUNet ID'].trim().toLowerCase();
      if (output_set[sunetid] != null) {
        continue;
      }
      output.push(sunetid);
      output_set[sunetid] = true;
    }
    output.sort();
    return output;
  });
  app.get('/attendance', auth, function*(){
    var sunetid, seminars;
    sunetid = this.request.query.sunetid;
    console.log("this request is for");
  	console.log(sunetid);
  	if (sunetid == null) {
      this.body = JSON.stringify([]);
      return;
    }
    seminars = (yield get_seminars_attended_by_user(sunetid));
    console.log("seminars: ");
    console.log(seminars);
    return this.body = JSON.stringify(seminars);
  });
  app.get('/pass_nopass', auth, function*(){
    var output, all_users, i$, len$, user, seminars_attended, passed;
    output = [];
    all_users = (yield list_all_users());
    for (i$ = 0, len$ = all_users.length; i$ < len$; ++i$) {
      user = all_users[i$];
      seminars_attended = (yield get_seminars_attended_by_user(user));
      passed = seminars_attended.length >= 9;
      output.push(user + ": " + passed);
    }
    return this.body = output.join('\n');
  });
  app.get('/nopass', auth, function*(){
    var output, all_users, i$, len$, user, seminars_attended, passed;
    output = [];
    all_users = (yield list_all_users());
    for (i$ = 0, len$ = all_users.length; i$ < len$; ++i$) {
      user = all_users[i$];
      seminars_attended = (yield get_seminars_attended_by_user(user));
      passed = seminars_attended.length >= 9;
      if (!passed) {
        output.push(user + "");
      }
    }
    return this.body = output.join('\n');
  });

  index_contents = fs.readFileSync('www/index.html', 'utf-8');
  serve_static = koaStatic(__dirname + '/www');
  for (i$ = 0, len$ = (ref$ = glob.sync('www/**')).length; i$ < len$; ++i$) {
    (fn$.call(this, ref$[i$]));
  }

  app.get('/', auth, function*(){
    var email, ref$, index_with_login;
    email = (ref$ = this.req.user.primary_email) != null
      ? ref$
      : (ref$ = this.req.user.email) != null
        ? ref$
        : this.req.user.mail;
    index_with_login = index_contents.replace('SOME_USERNAME_GOES_HERE', email);
    return this.body = index_with_login;
  });
  kapp.use(app.middleware());
  port = (ref$ = process.env.PORT) != null ? ref$ : 5000;
  if (on_heroku) {
    kapp.listen(port);
    console.log("on heroku, listening to port " + port + " visit http://localhost:" + port);
  } else {
    selfSignedHttps(kapp.callback()).listen(5000, '0.0.0.0');
    console.log("running locally, listening to port " + port + " visit https://localhost:" + port);
  }
  function fn$(filepath){
    var fileroute;
    fileroute = filepath.replace('www', '');
    if (fileroute === '') {
      return;
    }
    if (fileroute === '/index.html') {
      return;
    }
    app.get(fileroute, auth, serve_static);
  }
}).call(this);
